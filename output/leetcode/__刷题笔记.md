# 刷题笔记
## 2025-10-16
bst二叉搜索树的迭代写法非常简单，无需stack或者queue来模拟递归。  
原因在于无需回溯。  
而且中序遍历时是一个有序数列。 
p98验证二叉树的时候，我写了这样的逻辑：  
```cpp
if(root==NULL)  
        return true;  
        if(root->left->val<root->val&&root->right->val>root->val)
        {
            return isValidBST(root->left)&&isValidBST(root->right);
        }
        return false;
```
随即发现很尴尬，我无法保证两个子节点不为空，在外层多套一个逻辑又很啰嗦。  

```cpp
class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) 
    {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val)
         maxVal = root->val;
        else 
        return false;
        bool right = isValidBST(root->right);

        return left && right;
    }
}；
```
代码随想录的实现如上。统一使用递归接口，很简洁。  
还有一个问题，我的代码只关心父子关系，有漏洞，需要传递一个下界，才能保证不出错。  
中序遍历本就是有序，maxvalue就是上一个遍历到的结点的值。  


## 2025-10-17
bst第k小的经典问题，只需要中序遍历取索引就可以。  
遇到一个问题，用数组里的数构造一个bst时，在递归函数里处理数组索引有些麻烦。  
但用一个for循环搭配普通的递归接口就好多了。（但直接传入index+1也可以啦）  
先做了一道用大写字母标记叶子，加上前序遍历构建一棵树的题目，那个时候调用递归就不可以直接对索引操作，因为中“左”右，你不知道左子树有多少个结点，无法直接跳过去  
又练习使用了unordered map和小顶堆，哈希表的好处在于可以让一个数据对上不同的数据类型的数据。  
小顶堆用在实现huffman编码非常理想。  

## 2025-10-19
写力扣p98的时候，在纠结迭代的写法，为什么if逻辑能那么果断。  
问了gpt，才知道我一直在钻没必要的牛角尖。bst中序遍历本来就是有序数列，我只需要有一个pre，一个cur双指针检查是单调数列就可以了，不需要考虑递归来递归去时两个指针真的是父子节点，还是兄弟，左右子树的问题  

## 2025-10-20
bst插入节点的逻辑很简单，无需担心重构结构的可能。顺着大小逻辑走下去，走到null即可。毕竟bst只是保证中序遍历是一个单调序列。  
给定一个序列，并不能唯一确定bst，因为中序序列显然不足以确定一棵树。  
前＋中，中＋后都可以，前＋后不行。
bst树中最左侧的点，就是最小的节点。我总是怀疑这个。从root出发一直往左侧走，不用考虑右子树，因为右子树的结点一定比根大。  
刷力扣不用管理内存，但最好养成清楚内存和避免野指针的情况。  
bst有一个很大的好处，迭代法模拟递归的时候无需使用栈。

## 2025-10-21
终于把树写完了！我总是纠结于递归在各种特殊情况下能否成立，没有关心最顶层  
只要坚持三点：1.参数和返回值 2.终止条件 3.单层逻辑 这样子去思考，就不会错。  
构造题是前序遍历，没有根就没有子节点。  
bst的有序性非常优良，一般考虑用中序遍历。  

----
回溯算法的结构是if+for
好处在于这个框架可自动管理状态无需手动分析，可剪枝，可复用，可伸缩，本质还是穷举。  

## 2025-10-22
p39,乍看很难,一个数字可以被无限次选取,实则继续坚持不吃回头草的原则,下层递归把自己本身排除出去就好。  
剪枝需要注意，要对数组先排序，否则会漏掉一些情况。  
p39和p40有微妙但很重要的区别。p40的数组里会有重复的数字，但是答案的组合不能有重复的。  
按照一般的回溯算法，假设数组已经排序好，假设有一个符合要求的数组要取三个2中的两个，那么第一个2和第三个2，第二个2和第三个2会算两次。但实际上应该是同一个。  
也就是说，在同一层上，（注意不是同一枝干，答案数组里可以有重复数字）如果有重复的数字应该跳过，sort之后逻辑很简单，直接对比相邻数字就可以。  
回溯算法要画一棵树来分析，每次调用递归函数，就往下走一层。