# 刷题笔记
## 2025-10-16
bst二叉搜索树的迭代写法非常简单，无需stack或者queue来模拟递归。  
原因在于无需回溯。  
而且中序遍历时是一个有序数列。 
p98验证二叉树的时候，我写了这样的逻辑：  
```cpp
if(root==NULL)  
        return true;  
        if(root->left->val<root->val&&root->right->val>root->val)
        {
            return isValidBST(root->left)&&isValidBST(root->right);
        }
        return false;
```
随即发现很尴尬，我无法保证两个子节点不为空，在外层多套一个逻辑又很啰嗦。  

```cpp
class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) 
    {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val)
         maxVal = root->val;
        else 
        return false;
        bool right = isValidBST(root->right);

        return left && right;
    }
}；
```
代码随想录的实现如上。统一使用递归接口，很简洁。  
还有一个问题，我的代码只关心父子关系，有漏洞，需要传递一个下界，才能保证不出错。  
中序遍历本就是有序，maxvalue就是上一个遍历到的结点的值。  


## 2025-10-17
bst第k小的经典问题，只需要中序遍历取索引就可以。  
遇到一个问题，用数组里的数构造一个bst时，在递归函数里处理数组索引有些麻烦。  
但用一个for循环搭配普通的递归接口就好多了。（但直接传入index+1也可以啦）  
先做了一道用大写字母标记叶子，加上前序遍历构建一棵树的题目，那个时候调用递归就不可以直接对索引操作，因为中“左”右，你不知道左子树有多少个结点，无法直接跳过去  
又练习使用了unordered map和小顶堆，哈希表的好处在于可以让一个数据对上不同的数据类型的数据。  
小顶堆用在实现huffman编码非常理想。  

## 2025-10-19
写力扣p98的时候，在纠结迭代的写法，为什么if逻辑能那么果断。  
问了gpt，才知道我一直在钻没必要的牛角尖。bst中序遍历本来就是有序数列，我只需要有一个pre，一个cur双指针检查是单调数列就可以了，不需要考虑递归来递归去时两个指针真的是父子节点，还是兄弟，左右子树的问题  

## 2025-10-20
bst插入节点的逻辑很简单，无需担心重构结构的可能。顺着大小逻辑走下去，走到null即可。毕竟bst只是保证中序遍历是一个单调序列。  
给定一个序列，并不能唯一确定bst，因为中序序列显然不足以确定一棵树。  
前＋中，中＋后都可以，前＋后不行。
bst树中最左侧的点，就是最小的节点。我总是怀疑这个。从root出发一直往左侧走，不用考虑右子树，因为右子树的结点一定比根大。  
刷力扣不用管理内存，但最好养成清楚内存和避免野指针的情况。  
bst有一个很大的好处，迭代法模拟递归的时候无需使用栈。

## 2025-10-21
终于把树写完了！我总是纠结于递归在各种特殊情况下能否成立，没有关心最顶层  
只要坚持三点：1.参数和返回值 2.终止条件 3.单层逻辑 这样子去思考，就不会错。  
构造题是前序遍历，没有根就没有子节点。  
bst的有序性非常优良，一般考虑用中序遍历。  

----
回溯算法的结构是if+for
好处在于这个框架可自动管理状态无需手动分析，可剪枝，可复用，可伸缩，本质还是穷举。  

## 2025-10-22
p39,乍看很难,一个数字可以被无限次选取,实则继续坚持不吃回头草的原则,下层递归把自己本身排除出去就好。  
剪枝需要注意，要对数组先排序，否则会漏掉一些情况。  
p39和p40有微妙但很重要的区别。p40的数组里会有重复的数字，但是答案的组合不能有重复的。  
按照一般的回溯算法，假设数组已经排序好，假设有一个符合要求的数组要取三个2中的两个，那么第一个2和第三个2，第二个2和第三个2会算两次。但实际上应该是同一个。  
也就是说，在同一层上，（注意不是同一枝干，答案数组里可以有重复数字）如果有重复的数字应该跳过，sort之后逻辑很简单，直接对比相邻数字就可以。  
回溯算法要画一棵树来分析，每次调用递归函数，就往下走一层。

## 2025-10-27
继续写了回溯算法。
回溯算法是一个树状结构，要铭记。
p131是一道比较特别的题目。切割字符串来判别，其实和组合问题很类似。在组合问题里，for循环是在选取组合中的第一个元素  
当然切割也是如此，只不过使用了substr，for循环到的整片区域都要记录下去，所以只要记住for循环是选取第一个元素，递归才是进入下一层，下一个元素就可以了。  
初步接触了动态规划。大问题的解可以借助小问题的解得到，先解决小问题，从而可以不断复用。感觉是有记忆的递归，用空间换取了时间，让我想起了前缀表。  
KMP算法忘得差不多了，需要再去复习。  
好几天没刷力扣，羞愧。课很多的日子也有坚持刷，没课的日子释放累积的疲惫，反而坚持不下去了。  

## 2025-10-28
写p90的时候，看代码随想录的去重加上了一个used数组，我感觉很没必要。只需要先排序数组，然后如果数组里i=i-1就跳过即可。  
去重要注意startindex等于0的特殊情况，否则数组越界。边界情况不可不慎重。  
p491感觉说得很不清楚，给的例子不仅没有代表性甚至有误导性。 
可以用哈希表去重，也可以用数组，因为给定的数字范围很小，反而节省了很多时间。这个数组不能重排序，所以相同的数字可能跳的很远，无法用之前的方法去重。  
在力扣的题解里看到了一个很不错的去重方法：用一个数组pre来记录对于num[i]，之前若没有重复元素则记作-1，有则记录最靠后的元素的下标。  
原题有限制nums的长度最大是15，所以相比以数字大小对应数组下标的方法节省了大量空间。  
我们有一个记录现有数组的vector，函数参数里有一个记录vector最后一个元素在num数组对应的下标的参数last。如果pre[i]的值大于last+1，说明现在选取的这个数和pre[i]的数一样，不应该选取，因为在之前的逻辑已经选取过那一个数了。  
比如 4 6 7 5 7
选4 6 -- 7 是不对的。  
选4 6 7 ---- 7是可以的。

## 2025-10-29
写p47，很令人讶异的是，used数组的去重条件设为第i-1个元素为true或false都可以。代码随想录说一个角度是从树枝角度去重，一个角度是从树层角度去重，豁然开朗。  
p332用回溯超时了，这道题给我的感觉就是欧拉图呀，不过图论的题还没开始刷。用离散数学相关知识应该能做到剪枝很多。  
N皇后，这道题真是看人就让人感到愉悦，甚至想去学下国际象棋了。如此简明易懂的题干，如此完美地应用了国际象棋的特性，如此完美地匹配回溯算法！  
棋盘是二维的，对应回溯搜索的树层和树枝，需要注意用什么容器，题目要求的是存着string的数组，一个string代表一行，string可以用（n，某个char）来构造，vector也可以用（n，某种string）  
默认是空白的地方是. 

## 2025-11-18
许久没有写刷题笔记。  
数据结构教到了图论，我贪心算法写一半，为了应付机考，先写图论。  
图的存储方式一般是邻接矩阵邻接表，邻接表一维数组一维链表（c++是list），矩阵是二维数组。顶点编号从0开始时要注意数组申请要到n+1  
bfs和dfs很熟悉了，在树里一直写。数据结构从树变成了矩阵。不过其实树就是图的一种特殊形式嘛。  
图论要学很多算法的感觉。孤岛的总面积这道题，一开始想不到怎么判断是孤岛，最后的方法就是从边缘出发把所有相邻的陆地标为0就可以。  

## 2025-11-21
写海岸线计算的时候，提到一个办法，先计算岛屿面积，然后计算面积*4-相邻边*2就是周长。计算相邻边的时候要注意，只算上和左，如果上下左右都算，则会重复计算相邻边。代码随想录说这实际上不用bfs或者dfs，我不认同，无非都是遍历每一个方格，使用递归可以写得更简洁，分类情况搞清楚就可以。除了水，陆地，边界之外，要注意不能重复遍历，所以给遍历过的陆地标为2，这样其实就等价于双层for循环找1了。容易漏掉这种情况导致重复计算。
寻找最短路径的时候，广搜好用，找到的第一条路径肯定就是最短的。深搜需要记录路径长度，麻烦。  
unordered_map可以用来记录pair，会自动查重，我记得底层是红黑树，set就是哈希表，查找时间O(1)。  
查找set中有无某个元素，用count函数，返回值为0或1，或者find==end()，则是没有。

## 2025-11-24
并查集用来解决连通性问题。prim算法无需用到，kruskal需要。判断两个元素是否在一个连通图（集合）里。  
并查集常见操作：find，join，issame  
路径压缩很重要，时间复杂度会在O(1)到O(logn)之间。find，join，issame都会压缩路径。  

## 2025-11-26
kruskal算法以边为核心，找权重最小的边，判断是否能链接两个不在同一集合的点。使用了并查集的数据结构。  
prim算法以点为核心，从点出发，分析它的每一条边，有一个minDist数组记录到各点的长度，非常像dijkstra算法，但是后者的distance需要累加，prim不需要。  

## 2025-11-28
邻接表比邻接矩阵节省很多空间，用vector嵌套的二维数组就可以实现邻接表。一开始我以为只有利用链表才能算邻接表，但用链表写又很麻烦。  
vector是动态的数组，接口又简洁好用。当然也可以用c++包装好的list。  

## 2025-12-03
Astar是广搜的一种改良版。搜索最短路的时候，无权图用广搜，有权用dijkstra。  
A*算法 并不是一个明确的最短路算法，A*算法搜的路径如何，完全取决于 启发式函数怎么写。

## 2025-12-04
分糖果（p135）这道题给我的印象非常深刻。一开始我觉得很简单，为什么能配得上困难呢？后来发现，如果我两边同时考虑的话，可能会影响到已经处理好rating条件的元素，从而导致整个数组的值都要重新处理。代码随想录的方法是先保证一边，再从右往左遍历保证另一边，非常聪明。  

## 2025-12-06
vector其实是一个很暴力的实现，在要扩容的时候，重新申请一个原数组两倍大小的数组，拷贝过去，再释放原数组内存。  
追求速度的话，尽量少用。但是封装得很好，写oj很香。尽量用链表，c++里是list，注意迭代器iterator是一种数据类型，可以用auto，省去一大堆麻烦。
``` cpp
std::list<vector<int>>::iterator it = que.begin();
        while (position--) 
        {
            it++;
        }
        que.insert(it, people[i]);
```
写射气球这一题的时候，我突然感觉代码随想录的解法好像和我理解的贪心不太一样，是一种被动的贪心。问了gemini，回答非常精妙。
虽然在算法分类上，这两种都被称为“贪心算法（Greedy Algorithm）”，但它们的“**贪心点**”确实不同。我们可以这样来理解你的感受：
### 1. 按右边界排序（正如你说的：更像“主动贪心”）
*   **策略**：“我知道这个气球马上就要结束了（右边界到了），我**必须**射箭了。既然必须射，为了利益最大化，我就射在它的**最右边缘**，希望能顺便带走后面更多刚开始的气球。”
*   **心态**：这是一个**进攻型**的贪心。它在主动寻找“一箭双雕、一箭三雕”的最佳**射击位置**。
*   **核心**：贪的是**位置**（Position）。
### 2. 按左边界排序（你的解法：更像“被动贪心”或“懒惰贪心”）
*   **策略**：“我不想射箭，能省则省。来了一个新气球，只要它跟前面的气球有重叠，我就把它算进‘当前这支箭’的射程里（通过缩小公共右边界 `min`）。直到来了一个气球完全脱节了（`start > end`），我才**不得不**承认上一支箭不够用了，被迫掏出下一支箭。”
*   **心态**：这是一个**防守型**的贪心，或者叫**懒惰策略**。你的目标是让当前这支箭的“寿命”尽可能长，不到万不得已不开新箭。
*   **核心**：贪的是**容量**（Capacity）。你在贪婪地想让一支箭“装”下尽可能多的气球。
#### 为了全局最省，我在局部极其吝啬。
一开始我想的是打气球重叠最多的地方，但是要反复查找最大值，而且还要更新数组，还要先读一遍数组记录重叠个数，非常麻烦。以上方法扫一遍就可以了，虽然有点反直觉，但效果是一样的。  
p435这个无重叠区间，和射气球其实本质一模一样，我不得不承认一开始没看出来。一个是最大不相容区间数量，一个是最少点覆盖所有控件，其实是一样的。  
