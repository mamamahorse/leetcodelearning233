# 刷题笔记
## 2025-10-17
bst二叉搜索树的迭代写法非常简单，无需stack或者queue来模拟递归。
原因在于无需回溯。
而且中序遍历时是一个有序数列。
p98验证二叉树的时候，我写了这样的逻辑：
if(root==NULL)
        return true;
        if(root->left->val<root->val&&root->right->val>root->val)
        {
            return isValidBST(root->left)&&isValidBST(root->right);
        }
        return false;
随即发现很尴尬，我无法保证两个子节点不为空，在外层多套一个逻辑又很啰嗦。
class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) 
    {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val)
         maxVal = root->val;
        else 
        return false;
        bool right = isValidBST(root->right);

        return left && right;
    }
};
代码随想录的实现如上。统一使用递归接口，很简洁。
还有一个问题，我的代码只关心父子关系，有漏洞。
需要传递一个下界，才能保证不出错。
中序遍历本就是有序，maxvalue就是上一个遍历到的结点的值。
