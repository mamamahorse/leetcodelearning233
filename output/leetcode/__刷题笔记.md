# 刷题笔记
## 2025-10-16
bst二叉搜索树的迭代写法非常简单，无需stack或者queue来模拟递归。  
原因在于无需回溯。  
而且中序遍历时是一个有序数列。 
p98验证二叉树的时候，我写了这样的逻辑：  
```cpp
if(root==NULL)  
        return true;  
        if(root->left->val<root->val&&root->right->val>root->val)
        {
            return isValidBST(root->left)&&isValidBST(root->right);
        }
        return false;
```
随即发现很尴尬，我无法保证两个子节点不为空，在外层多套一个逻辑又很啰嗦。  

```cpp
class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) 
    {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val)
         maxVal = root->val;
        else 
        return false;
        bool right = isValidBST(root->right);

        return left && right;
    }
}；
```
代码随想录的实现如上。统一使用递归接口，很简洁。  
还有一个问题，我的代码只关心父子关系，有漏洞，需要传递一个下界，才能保证不出错。  
中序遍历本就是有序，maxvalue就是上一个遍历到的结点的值。  


## 2025-10-17
bst第k小的经典问题，只需要中序遍历取索引就可以。  
遇到一个问题，用数组里的数构造一个bst时，在递归函数里处理数组索引有些麻烦。  
但用一个for循环搭配普通的递归接口就好多了。（但直接传入index+1也可以啦）  
先做了一道用大写字母标记叶子，加上前序遍历构建一棵树的题目，那个时候调用递归就不可以直接对索引操作，因为中“左”右，你不知道左子树有多少个结点，无法直接跳过去  
又练习使用了unordered map和小顶堆，哈希表的好处在于可以让一个数据对上不同的数据类型的数据。  
小顶堆用在实现huffman编码非常理想。  

## 2025-10-19
写力扣p98的时候，在纠结迭代的写法，为什么if逻辑能那么果断。  
问了gpt，才知道我一直在钻没必要的牛角尖。bst中序遍历本来就是有序数列，我只需要有一个pre，一个cur双指针检查是单调数列就可以了，不需要考虑递归来递归去时两个指针真的是父子节点，还是兄弟，左右子树的问题  

## 2025-10-20
bst插入节点的逻辑很简单，无需担心重构结构的可能。顺着大小逻辑走下去，走到null即可。毕竟bst只是保证中序遍历是一个单调序列。  
给定一个序列，并不能唯一确定bst，因为中序序列显然不足以确定一棵树。  
前＋中，中＋后都可以，前＋后不行。
bst树中最左侧的点，就是最小的节点。我总是怀疑这个。从root出发一直往左侧走，不用考虑右子树，因为右子树的结点一定比根大。  
刷力扣不用管理内存，但最好养成清楚内存和避免野指针的情况。  
bst有一个很大的好处，迭代法模拟递归的时候无需使用栈。
