# 刷题笔记
## 2025-10-16
bst二叉搜索树的迭代写法非常简单，无需stack或者queue来模拟递归。  
原因在于无需回溯。  
而且中序遍历时是一个有序数列。 
p98验证二叉树的时候，我写了这样的逻辑：  
```cpp
if(root==NULL)  
        return true;  
        if(root->left->val<root->val&&root->right->val>root->val)
        {
            return isValidBST(root->left)&&isValidBST(root->right);
        }
        return false;
```
随即发现很尴尬，我无法保证两个子节点不为空，在外层多套一个逻辑又很啰嗦。  

```cpp
class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) 
    {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val)
         maxVal = root->val;
        else 
        return false;
        bool right = isValidBST(root->right);

        return left && right;
    }
}；
```
代码随想录的实现如上。统一使用递归接口，很简洁。  
还有一个问题，我的代码只关心父子关系，有漏洞，需要传递一个下界，才能保证不出错。  
中序遍历本就是有序，maxvalue就是上一个遍历到的结点的值。  


## 2025-10-17
bst第k小的经典问题，只需要中序遍历取索引就可以。  
遇到一个问题，用数组里的数构造一个bst时，在递归函数里处理数组索引有些麻烦。  
但用一个for循环搭配普通的递归接口就好多了。（但直接传入index+1也可以啦）  
先做了一道用大写字母标记叶子，加上前序遍历构建一棵树的题目，那个时候调用递归就不可以直接对索引操作，因为中“左”右，你不知道左子树有多少个结点，无法直接跳过去  
又练习使用了unordered map和小顶堆，哈希表的好处在于可以让一个数据对上不同的数据类型的数据。  
小顶堆用在实现huffman编码非常理想。  
